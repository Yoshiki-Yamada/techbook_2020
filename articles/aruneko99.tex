\section{はじめに}
どうも、みなさんおなじみのあるねこさんです。この記事ではPythonの型アノテーション機能を
活用し、型の力を借りつつPython上でHaskellライクな型クラスモデルを再現する方法を紹介します。また実際にPythonの型アノテーション機能を使う上でのメリットや注意点をその都度解説します。なお今回作成したものは僕のGithubリポジトリ\footnote{\url{https://github.com/aruneko/FunctionalPy}}に掲載してありますので、ぜひご利用ください。

それでは型の世界へレッツゴー！

\section{型とPythonとmypyと}
\subsection{Pythonにおける型ヒンティング}
あまりなじみがないかもしれませんが、Python3系では関数やその引数に型アノテーションを書くことができ、その機能はバージョンアップごとに強化されています。特にPython3.5ではtypingモジュールが追加されてジェネリックな型アノテーションを書けるようになり、3.6では個別の変数にも書くことができるようになりました。また、高階関数などもサポートされていて、多彩な型を表現できるようになっています。

ただしこれらの型アノテーションは実行時には完全に無視され、いかなる値が渡ってきてもチェックは行われません。あくまで人間や静的コード解析ツールにとってわかりやすくなるためだけの機能となっています。そのため、List[int]型に特化した以下のコードはList[str]を与えても何のエラーや警告も出さずに実行できます。

\inputpython{./assets/aruneko/sample01.py}

\subsection{mypyによる型の解析}
型チェックはmypyというツールを使って行います。あるいは、Pycharmにデフォルトで搭載されている型チェック機能も利用できます。ただしこれらのツールで同じコードを解析した際に同じ結果になるかは未検証です。この記事では特に断りが無い場合mypyを利用します。

mypyをインストールするにはpipコマンドを利用します。一昔前は``mypy-lang''パッケージとして登録されていましたが、現在は``mypy''パッケージに名称を変更しているので、過去の資料を参照する際は注意が必要です。

\begin{bashcode}
pip install mypy
\end{bashcode}

それではmypyでの解析を試してみましょう。まず先ほどのサンプルコードを解析します。mypyコマンドで解析したいファイル名を引数に指定することで解析することができます。今回は型エラーを発生させるコードを書いているため、型チェックの結果int型とstr型は合致しないというエラーが発生しています。

\begin{bashcode}
mypy sample01.py
sample01.py:9: error: List item 0 has incompatible type "str"; expected "int"
sample01.py:9: error: List item 1 has incompatible type "str"; expected "int"
sample01.py:9: error: List item 2 has incompatible type "str"; expected "int"
\end{bashcode}

それではジェネリックを使って先ほどのコードを書き直し、もう一度チェックを書けてみましょう。今回は型エラーが発生しないため、特に何も表示されずmypyが終了します。

\inputpython{./assets/aruneko/sample02.py}

\begin{bashcode}
mypy sample02.py
\end{bashcode}

このmypyによる型チェックをCIと組み合わせて、型を合致しないコードがコミットされたときにテストを通らないようにすることで想定外の関数の利用を制限し、より安全なコードを書くヒントを得ることができるメリットがあります。

これで基本的なmypyの使い方と型の書き方が説明できました。それではいよいよ型クラスを作っていきましょう。

\section{型クラスを作る}
\subsection{型クラス概要}
型クラスとは、その型クラスを実装した具象型がどう振る舞うべきかを定義したものです。JavaでいうInterfaceを想像するとわかりやすいかもしれません。

今回は特に有名な``Functor''、``Applicative''、``Monad''の3つの型クラスを実装します。これらの型クラスは継承関係にあり、ListやMaybe(ScalaのOption)などよく使われる型を抽象化することができます。それぞれの型クラスの詳細は実装時に詳しく説明します。

\subsection{Functor型クラスの実装}
Functorはリストなどの全要素に1引数関数を適用するmap関数をメソッドとして持っている型クラスです。まずFunctorのコードを紹介します。

\inputpython{./assets/aruneko/Functor.py}

先ほども述べたとおり、型クラスはいわゆるインターフェースと類似するものですので、PythonのABCパッケージを使って抽象クラスとして定義していきます。また、Functorはコンテナ的な性質を持つため、Generic[A]を継承してこれ自身がジェネリックな型であることを明示します。

続いて、mapメソッドの定義を記述します。mapメソッドは1引数関数を取ってそれを適用したFunctorを返すため、Callableを用いて型宣言を行います。ただしPythonではクラスの定義中に自分自身のクラス名を利用することができないため、mypyやPyCharmがサポートしているコメントによる型記法を利用します。またmapは抽象メソッドで実装を持たないため、passを書いて実装がないことを明示します。

\subsection{Applicative型クラスの実装}
続いてApplicative型クラスを定義しましょう。この型クラスは本来``pure''と``ap''の2つのメソッドを持つべきです。しかし``pure''はある値をアプリカティブ値にするための関数で、これは各クラスが``\verb+__init__+''メソッドを実装するだけで実現できてしまいます。従って今回は手抜きをして``ap''だけをApplicativeのメソッドとして定義します。

では``ap''メソッドが何者かと言いますと、1引数関数が入ったApplicative値を引数にとって、その関数にApplicative値の中身に入っている値を適用する関数です。言葉で説明するのも難しいので、さっそく型定義を見てみましょう。

\inputpython{./assets/aruneko/Applicative.py}

まず大前提としてApplicativeはFunctorとして振る舞うこともできるためFunctorを継承するところから始めます。そしてネストが深い上に長くて読みづらいですが、1引数関数を値として持つApplicative値を引数にとってApplicative値を返すという型を書いておきます。

\subsection{Monad型クラスの実装}
最後にMonad型クラスを定義しましょう。Monadと聞くと身構える人もいるかもしれませんが、きちんと説明しますので大丈夫です。さっそく実装を見てみましょう。

\inputpython{./assets/aruneko/Monad.py}

Monad型クラスはいわゆる``\verb+flat_map+''をメソッドに持つ型クラスです。``\verb+flat_map+''はMonad値を返す1引数関数を引数にとってMonad値に適用し、その際2重になったMonad値を剥がすメソッドです。本来であればApplicativeの``pure''と同じ働きをする関数もメソッドに持つべきですが、上記の理由により省略します。Monad型クラスもまたFunctorとして振る舞い、さらにApplicativeとしても振る舞うため、Applicative型クラスを継承しています。

ひとまずこれで今回ご紹介する型クラスの定義は終わったので、次はいよいよこれらの型クラスを具象クラスに実装していきます。

\section{List Monadを作る}
\subsection{ベースを作る}
それではさっそくList Monadのベースを作っていきます。既存のlistを継承し、Monad型クラスを実装します。ただし今回はtypingパッケージのListクラスと名前を被らせないために、Scalaに倣って``Seq''クラスと命名します。ひとまず機械的に作ってしまいましょう。以下のような実装になります。

\inputpython{./assets/aruneko/Seq01.py}

実装するメソッドの型宣言は今実装しているクラスに合わせて``Seq''に変更しておきます。また、``\verb+__init__+''の実装は可変長引数を受け取ってリストに詰め直す動作をするように作ってあります。こうすることでSeq専用のリテラルが追加されたかのように記述できます。

\subsection{各種型クラスの実装}
ではまずSeqをFunctorにするために、mapの実装をしていきます。といってもリスト内包表記を使えば良いのでとても簡単です。ここでのselfは自分が保持しているlistになっているため、selfを直接イテレートさせればOKです。あとは引数にとってきた関数を適用して新たなリストを作成し、それを展開してもう一度Seqに詰め直せば完成です。

\inputpython{./assets/aruneko/Seq_map.py}

続いてSeqにApplicativeを実装するために、apの実装を考えます。apは引数に``1引数関数''のSeqを取ります。これをSeqに適用するわけですから、全要素数は``$\mbox{引数のリストの長さ} \times \mbox{対象のリストの長さ}$''になります。単純にループを回すだけでは実装できないので、少々気持ち悪いですが2重に回します。このように2重ループを回すことでSeqから取り出した関数に対してselfの値を取り出して適用していき、入れ子になっていないSeqを作り出します。

\inputpython{./assets/aruneko/Seq_ap.py}

では最後にflat\_mapを実装しましょう。これでSeqはMonadになることができます。今度も引数に取った関数がSeqを返してしまう都合上単純にループを回すと入れ子構造になってしまうため、それを防止するために2重ループを回します。selfから取り出した値を引数に取った関数に適用し、その結果を1つずつ取り出してリストにします。あとはSeqに詰め直して完成です。

\inputpython{./assets/aruneko/Seq_flat_map.py}

これでFunctor、Applicative、Monadに必要な全てのメソッドを実装できました。この時点でmypyを使って型検査を行いエラーがないことを確かめたいのですが、実はmypyにはインターフェースを実装したときの型検査にバグがあり、正しく実装をしているにもかかわらず親クラスと型が合わないという型エラーを出してしまいます。この問題についてはGithub上で議論されていますが\footnote{\url{https://github.com/python/typing/issues/241}}、今のところ解決していません。あまり気にしないでおきましょう。

\section{まとめ}
ここまでPython上で型を定義しながらMonad則を満たすSeqクラスを作ってきました。皆さんにはPythonで型を書き、それをチェックする方法を少しでも伝えられれば嬉しいです。また、その型の力を使ってMonadまで作れてしまうこともぜひ知っていただけるとありがたいです。

読者の皆さんもぜひ新規Pythonコードには型定義をしっかりと書いて、CIにmypyを組み込んでチェックしてみてください。数日後の自分がそのコードを読み返したときに型というヒントを得ることができ、きっと開発の手助けになると思います。それでは良き型ライフを！