\section{はじめに}
どうも、みなさんおなじみのあるねこさんです。この記事ではPythonの型アノテーション機能を
活用し、型の力を借りつつPython上でHaskellライクな型クラスモデルを再現する方法を紹介します。また実際にPythonの型アノテーション機能を使う上でのメリットや注意点をその都度解説します。それでは型の世界へレッツゴー！

\section{型とPythonとmypyと}
\subsection{Pythonにおける型ヒンティング}
あまりなじみがないかもしれませんが、Python3系では関数やその引数に型アノテーションを書くことができ、その機能はバージョンアップごとに強化されています。特にPython3.5ではtypingモジュールが追加されてジェネリックな型アノテーションを書けるようになり、3.6では個別の変数にも書くことができるようになりました。また、ジェネリックや高階関数などもサポートされていて、多彩な型を表現できるようになっています。

ただしこれらの型アノテーションは実行時には完全に無視され、いかなる値が渡ってきてもチェックは行われません。あくまで人間や静的コード解析ツールにとってわかりやすくなるためだけの機能となっています。そのため、List[int]型に特化した以下のコードはList[str]を与えても何のエラーや警告も出さずに実行できます。

\inputpython{./assets/aruneko/sample01.py}

\subsection{mypyによる型の解析}
型チェックはmypyというツールを使って行います。あるいは、Pycharmにデフォルトで搭載されている型チェック機能も利用できます。ただしこれらのツールは同じコードを解析しても微妙に違う結果を返すので要注意です。この記事では特に断りが無い場合mypyを利用します。

mypyをインストールするにはpipコマンドを利用します。一昔前は``mypy-lang''パッケージとして登録されていましたが、現在は``mypy''パッケージに名称を変更しているので、過去の資料を参照する際は注意が必要です。

\begin{bashcode}
pip install mypy
\end{bashcode}

それではmypyでの解析を試してみましょう。まず先ほどのサンプルコードを解析します。mypyコマンドで解析したいファイル名を引数に指定することで解析することができます。今回は型エラーを発生させるコードを書いているため、型チェックの結果int型とstr型は合致しないというエラーが発生しています。

\begin{bashcode}
mypy sample01.py
sample01.py:9: error: List item 0 has incompatible type "str"; expected "int"
sample01.py:9: error: List item 1 has incompatible type "str"; expected "int"
sample01.py:9: error: List item 2 has incompatible type "str"; expected "int"
\end{bashcode}

それではジェネリックを使って先ほどのコードを書き直し、もう一度チェックを書けてみましょう。今回は型エラーが発生しないため、特に何も表示されずmypyが終了します。

\inputpython{./assets/aruneko/sample02.py}

\begin{bashcode}
mypy sample02.py
\end{bashcode}

このmypyによる型チェックをCIと組み合わせて、型を合致しないコードがコミットされたときにテストを通らないようにすることで想定外の関数の利用を制限し、より安全なコードを書くヒントを得ることができるメリットがあります。

これで基本的なmypyの使い方と型の書き方が説明できました。それではいよいよ型クラスを作っていきましょう。

\section{型クラスを作る}
\subsection{型クラス概要}
型クラスとは、その型クラスを実装したある型がどう振る舞うべきかを定義したものです。JavaでいうInterfaceを想像するとわかりやすいかもしれません。

今回は特に有名な``Functor''、``Applicative''、``Monad''の3つの型クラスを実装します。これらの型クラスは継承関係にあり、ListやMaybe(ScalaのOption)などよく使われる型を抽象化することができます。それぞれの型クラスの詳細は実装時に詳しく説明します。

\subsection{Functor型クラスの実装}
Functorはリストなどの全要素に1引数関数を適用するmap関数をメソッドとして持っている型クラスです。まずFunctorのコードを紹介します。

\inputpython{./assets/aruneko/Functor.py}

先ほども述べたとおり、型クラスはいわゆるインターフェースと類似するものですので、PythonのABCパッケージを使って抽象クラスとして実装していきます。また、Functorはコンテナ的な性質を持つため、Generic[A]を継承してこれ自身がジェネリックな型であることを明示します。

続いて、mapメソッドの定義を記述します。mapメソッドは1引数関数を取ってそれを適用したFunctorを返すため、Callableを用いて型宣言を行います。ただしPythonではクラスの定義中に自分自身のクラス名を利用することができないため、mypyやPyCharmがサポートしているコメントによる型記法を利用します。またmapは抽象メソッドで実装を持たないため、passを書いて実装がないことを明示します。

\subsection{Applicative型クラスの実装}
続いてApplicative型クラスを実装しましょう。この型クラスは本来``pure''と``ap''の2つのメソッドを持つべきです。しかし``pure''はある値をアプリカティブ値にするための関数で、これは各クラスが``\verb+__init__+''メソッドを実装するだけで実現できてしまいます。従って今回は手抜きをして``ap''だけをApplicativeのメソッドとして実装します。

では``ap''メソッドが何者かと言いますと、1引数関数が入ったApplicative値を引数にとって、その関数にApplicative値の中身に入っている値を適用する関数です。言葉で説明するのも難しいので、さっそく実装を見てみましょう。

\inputpython{./assets/aruneko/Applicative.py}

まず大前提としてApplicativeはFunctorとして振る舞うこともできるためFunctorを継承するところから始めます。そしてネストが深い上に長くて読みづらいですが、1引数関数を値として持つApplicative値を引数にとってApplicative値を返すという型を書いておきます。

\subsection{Monad型クラスの実装}
最後にMonad型クラスを実装しましょう。Monadと聞くと身構える人もいるかもしれませんが、きちんと説明しますので大丈夫です。さっそく実装を見てみましょう。

\inputpython{./assets/aruneko/Monad.py}

Monad型クラスはいわゆる``\verb+flat_map+''をメソッドに持つ型クラスです。``\verb+flat_map+''はMonad値を返す1引数関数を引数にとってMonad値に適用し、その際2重になったMonad値を剥がすメソッドです。本来であればApplicativeの``pure''と同じ働きをする関数もメソッドに持つべきですが、上記の理由により省略します。Monad型クラスもまたFunctorとして振る舞い、さらにApplicativeとしても振る舞うため、Applicative型クラスを継承しています。

ひとまずこれで今回ご紹介する型クラスの定義は終わったので、次はいよいよ具象クラスに実装していきます。

\section{List Monadを作る}
\subsection{ベースを作る}
それではさっそくList Monadのベースを作っていきます。既存のlistを継承し、Monad型クラスを実装します。ただし今回はtypingパッケージのListクラスと名前を被らせないために、Scalaに倣って``Seq''クラスと命名します。ひとまず機械的に作ってしまいます。以下のような実装になります。

\inputpython{./assets/aruneko/Seq01.py}

実装するメソッドの型宣言は今実装しているクラスに合わせて``Seq''に変更しておきます。また、``\verb+__init__+''の実装は可変長引数を受け取ってリストに詰め直す動作をするように作ってあります。こうすることでSeq専用のリテラルが追加されたかのように記述できます。

\section{Maybe Monadを作る}
